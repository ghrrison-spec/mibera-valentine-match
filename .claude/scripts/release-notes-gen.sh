#!/usr/bin/env bash
# release-notes-gen.sh - Generate release notes from CHANGELOG and commits
# Version: 1.0.0
#
# Extracts release notes from CHANGELOG.md for a given version,
# or generates minimal notes for bugfix releases.
#
# Usage:
#   .claude/scripts/release-notes-gen.sh --version <version> --pr <number> --type <cycle|bugfix|other>
#
# Output: Markdown to stdout
#
# Exit Codes:
#   0 - Success
#   1 - Missing required arguments
#   2 - CHANGELOG not found or version not found

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/bootstrap.sh"

# =============================================================================
# Defaults
# =============================================================================

VERSION=""
PR_NUMBER=""
PR_TYPE="other"

# =============================================================================
# Usage
# =============================================================================

usage() {
  cat <<'USAGE'
Usage: release-notes-gen.sh [OPTIONS]

Options:
  --version VERSION    Version to generate notes for (required)
  --pr NUMBER          Source PR number (required)
  --type TYPE          PR type: cycle|bugfix|other (default: other)
  --help               Show this help
USAGE
}

# =============================================================================
# CHANGELOG Extraction
# =============================================================================

# Extract the section for a specific version from CHANGELOG.md
extract_changelog_section() {
  local version="$1"
  local changelog="${PROJECT_ROOT}/CHANGELOG.md"

  if [[ ! -f "$changelog" ]]; then
    return 1
  fi

  # Extract content between "## [version]" and the next "## [" header
  local in_section=false
  local content=""

  while IFS= read -r line; do
    if [[ "$line" =~ ^##\ \[${version}\] ]]; then
      in_section=true
      continue
    fi
    if [[ "$in_section" == true && "$line" =~ ^##\ \[ ]]; then
      break
    fi
    if [[ "$in_section" == true ]]; then
      content="${content}${line}
"
    fi
  done < "$changelog"

  if [[ -z "$content" ]]; then
    return 1
  fi

  # Trim leading/trailing whitespace
  echo "$content" | sed -e 's/^[[:space:]]*//' -e '/^$/N;/^\n$/d'
}

# Count commits by type since the previous tag
count_commits() {
  local version="$1"
  local tag="v${version}"

  # Find previous tag
  local prev_tag
  prev_tag=$(git -C "$PROJECT_ROOT" tag -l 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname 2>/dev/null | \
    grep -A1 "^${tag}$" | tail -1)

  if [[ -z "$prev_tag" || "$prev_tag" == "$tag" ]]; then
    # No previous tag or only one tag â€” count all commits to tag
    prev_tag=""
  fi

  local range="${prev_tag:+${prev_tag}..}${tag}"
  local total feat_count fix_count

  total=$(git -C "$PROJECT_ROOT" rev-list "${range}" --count 2>/dev/null || echo "0")
  feat_count=$(git -C "$PROJECT_ROOT" log "${range}" --format='%s' 2>/dev/null | grep -cE '^feat' || echo "0")
  fix_count=$(git -C "$PROJECT_ROOT" log "${range}" --format='%s' 2>/dev/null | grep -cE '^fix' || echo "0")

  echo "${total} ${feat_count} ${fix_count}"
}

# =============================================================================
# Templates
# =============================================================================

generate_cycle_notes() {
  local version="$1" pr_number="$2"
  local changelog_content

  printf '## What'\''s New in v%s\n\n' "$version"

  if changelog_content=$(extract_changelog_section "$version"); then
    echo "$changelog_content"
  else
    echo "_No CHANGELOG section found for v${version}._"
  fi

  echo ""
  echo "### Source"
  echo ""
  printf -- '- PR: #%s\n' "$pr_number"

  # Try to get commit counts
  local counts
  if counts=$(count_commits "$version" 2>/dev/null); then
    local total feat_count fix_count
    read -r total feat_count fix_count <<< "$counts"
    printf -- '- Commits: %s (%s features, %s fixes)\n' "$total" "$feat_count" "$fix_count"
  fi

  echo ""
  echo "---"
  echo "Generated by Loa Post-Merge Automation"
}

generate_bugfix_notes() {
  local version="$1" pr_number="$2"

  printf '## Bug Fix Release v%s\n\n' "$version"

  # Try to get PR title for description
  local pr_title=""
  if command -v gh &>/dev/null; then
    pr_title=$(gh pr view "$pr_number" --json title --jq '.title' 2>/dev/null || true)
  fi

  if [[ -n "$pr_title" ]]; then
    echo "$pr_title"
  else
    echo "Bug fix release."
  fi

  echo ""
  printf -- '- PR: #%s\n' "$pr_number"
  echo ""
  echo "---"
  echo "Generated by Loa Post-Merge Automation"
}

generate_other_notes() {
  local version="$1" pr_number="$2"

  printf '## Release v%s\n\n' "$version"

  local changelog_content
  if changelog_content=$(extract_changelog_section "$version"); then
    echo "$changelog_content"
  else
    echo "Maintenance release."
  fi

  echo ""
  printf -- '- PR: #%s\n' "$pr_number"
  echo ""
  echo "---"
  echo "Generated by Loa Post-Merge Automation"
}

# =============================================================================
# Main
# =============================================================================

main() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --version) VERSION="$2"; shift 2 ;;
      --pr) PR_NUMBER="$2"; shift 2 ;;
      --type) PR_TYPE="$2"; shift 2 ;;
      --help|-h) usage; exit 0 ;;
      *) echo "ERROR: Unknown argument: $1" >&2; exit 1 ;;
    esac
  done

  if [[ -z "$VERSION" ]]; then
    echo "ERROR: --version is required" >&2
    exit 1
  fi

  if [[ -z "$PR_NUMBER" ]]; then
    echo "ERROR: --pr is required" >&2
    exit 1
  fi

  case "$PR_TYPE" in
    cycle) generate_cycle_notes "$VERSION" "$PR_NUMBER" ;;
    bugfix) generate_bugfix_notes "$VERSION" "$PR_NUMBER" ;;
    other|*) generate_other_notes "$VERSION" "$PR_NUMBER" ;;
  esac
}

main "$@"
