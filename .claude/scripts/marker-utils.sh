#!/usr/bin/env bash
# Loa Framework: Marker Utilities for Projen-Style Ownership
# Provides functions for detecting, adding, and verifying magic markers
#
# Usage:
#   source marker-utils.sh
#   has_marker /path/to/file
#   verify_hash /path/to/file
#   add_marker /path/to/file "1.15.0"

set -euo pipefail

# MED-001 FIX: Set restrictive umask for secure temp file creation
# This ensures mktemp creates files with 600 permissions atomically
umask 077

# =============================================================================
# Constants
# =============================================================================

readonly MARKER_PREFIX="@loa-managed"
readonly PACK_MARKER_PREFIX="@pack-managed"
readonly WARNING_LINE="DO NOT EDIT - Auto-generated by Loa framework"

# =============================================================================
# Core Functions
# =============================================================================

# Check if file has a Loa marker in the first 5 lines (or _loa_marker key for JSON)
# Usage: has_marker /path/to/file
# Returns: 0 if marker found, 1 if not
has_marker() {
  local file="${1:-}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    return 1
  fi

  local ext="${file##*.}"

  # For JSON files, check for _loa_marker key
  if [[ "$ext" == "json" ]]; then
    grep -q '"_loa_marker"' "$file" 2>/dev/null
    return $?
  fi

  head -5 "$file" 2>/dev/null | grep -q "$MARKER_PREFIX" 2>/dev/null
}

# Check if file has a pack marker
# Usage: has_pack_marker /path/to/file
# Returns: 0 if pack marker found, 1 if not
has_pack_marker() {
  local file="${1:-}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    return 1
  fi

  head -5 "$file" 2>/dev/null | grep -q "$PACK_MARKER_PREFIX" 2>/dev/null
}

# Extract Loa version from marker
# Usage: get_marker_version /path/to/file
# Returns: Version string or empty
get_marker_version() {
  local file="${1:-}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    echo ""
    return 1
  fi

  head -5 "$file" 2>/dev/null | grep "$MARKER_PREFIX" | sed -n 's/.*version: \([0-9.]*\).*/\1/p' | head -1
}

# Compute SHA-256 hash of file content EXCLUDING marker block
# Usage: compute_hash /path/to/file
# Returns: SHA-256 hash string
compute_hash() {
  local file="${1:-}"

  if [[ -z "$file" ]]; then
    echo ""
    return 1
  fi

  if [[ ! -f "$file" ]]; then
    # Empty file hash
    echo "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    return 0
  fi

  local ext="${file##*.}"
  local content=""

  case "$ext" in
    sh)
      # For shell: skip shebang (line 1) and marker/warning (lines 2-3)
      if head -1 "$file" | grep -q "^#!"; then
        content=$(tail -n +4 "$file")
      else
        # No shebang, skip first 2 lines (marker + warning)
        content=$(tail -n +3 "$file")
      fi
      ;;
    md)
      # For markdown: skip first line (HTML comment marker)
      if head -1 "$file" | grep -q "<!--.*$MARKER_PREFIX"; then
        content=$(tail -n +2 "$file")
      else
        content=$(cat "$file")
      fi
      ;;
    yaml|yml)
      # For YAML: skip first 2 lines (marker + warning comment)
      if head -1 "$file" | grep -q "^#.*$MARKER_PREFIX"; then
        content=$(tail -n +3 "$file")
      else
        content=$(cat "$file")
      fi
      ;;
    json)
      # For JSON: remove _loa_marker key if present
      if grep -q '"_loa_marker"' "$file" 2>/dev/null; then
        content=$(jq 'del(._loa_marker)' "$file" 2>/dev/null || cat "$file")
      else
        content=$(cat "$file")
      fi
      ;;
    *)
      # Default: skip first 2 lines if they contain marker
      if head -1 "$file" | grep -q "$MARKER_PREFIX"; then
        content=$(tail -n +3 "$file")
      else
        content=$(cat "$file")
      fi
      ;;
  esac

  echo -n "$content" | sha256sum | cut -d' ' -f1
}

# Verify file hash matches marker
# Usage: verify_hash /path/to/file
# Returns: VALID, MISMATCH, or NO_HASH
verify_hash() {
  local file="${1:-}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    echo "NO_HASH"
    return 1
  fi

  if ! has_marker "$file"; then
    echo "NO_HASH"
    return 0
  fi

  local ext="${file##*.}"
  local stored_hash=""

  # Extract stored hash from marker based on file type
  if [[ "$ext" == "json" ]]; then
    # For JSON files, extract hash from _loa_marker object using jq
    if command -v jq &>/dev/null; then
      stored_hash=$(jq -r '._loa_marker.hash // empty' "$file" 2>/dev/null)
    else
      # Fallback: grep-based extraction
      stored_hash=$(grep -o '"hash"[[:space:]]*:[[:space:]]*"[a-f0-9]*"' "$file" | sed 's/.*"\([a-f0-9]*\)"/\1/' | head -1)
    fi
  else
    stored_hash=$(head -5 "$file" | grep "$MARKER_PREFIX" | sed -n 's/.*hash: \([a-f0-9]*\).*/\1/p' | head -1)
  fi

  if [[ -z "$stored_hash" ]]; then
    echo "NO_HASH"
    return 0
  fi

  # Compute current hash
  local current_hash=""
  current_hash=$(compute_hash "$file")

  if [[ "$stored_hash" == "$current_hash" ]]; then
    echo "VALID"
    return 0
  else
    echo "MISMATCH"
    return 1
  fi
}

# Add marker to file based on file type
# Usage: add_marker /path/to/file "1.15.0"
add_marker() {
  local file="${1:-}"
  local version="${2:-1.15.0}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    echo "Error: File not found: $file" >&2
    return 1
  fi

  # Don't add if already has marker
  if has_marker "$file"; then
    echo "File already has marker: $file" >&2
    return 0
  fi

  local ext="${file##*.}"
  local hash=""
  hash=$(compute_hash "$file")

  local temp_file=""
  temp_file=$(mktemp)
  chmod 600 "$temp_file"

  case "$ext" in
    sh)
      # Preserve shebang if present
      if head -1 "$file" | grep -q "^#!"; then
        head -1 "$file" > "$temp_file"
        echo "# $MARKER_PREFIX: true | version: $version | hash: $hash" >> "$temp_file"
        echo "# $WARNING_LINE" >> "$temp_file"
        tail -n +2 "$file" >> "$temp_file"
      else
        echo "# $MARKER_PREFIX: true | version: $version | hash: $hash" > "$temp_file"
        echo "# $WARNING_LINE" >> "$temp_file"
        cat "$file" >> "$temp_file"
      fi
      ;;
    md)
      echo "<!-- $MARKER_PREFIX: true | version: $version | hash: $hash -->" > "$temp_file"
      cat "$file" >> "$temp_file"
      ;;
    yaml|yml)
      echo "# $MARKER_PREFIX: true | version: $version | hash: $hash" > "$temp_file"
      echo "# $WARNING_LINE" >> "$temp_file"
      cat "$file" >> "$temp_file"
      ;;
    json)
      # Add _loa_marker key to JSON
      if command -v jq &>/dev/null; then
        jq --arg v "$version" --arg h "$hash" \
          '. + {"_loa_marker": {"managed": true, "version": $v, "hash": $h}}' \
          "$file" > "$temp_file"
      else
        echo "Warning: jq not found, skipping JSON marker for $file" >&2
        rm -f "$temp_file"
        return 1
      fi
      ;;
    *)
      echo "# $MARKER_PREFIX: true | version: $version | hash: $hash" > "$temp_file"
      echo "# $WARNING_LINE" >> "$temp_file"
      cat "$file" >> "$temp_file"
      ;;
  esac

  mv "$temp_file" "$file"
  echo "Added marker to: $file"
}

# Remove marker from file
# Usage: remove_marker /path/to/file
remove_marker() {
  local file="${1:-}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    echo "Error: File not found: $file" >&2
    return 1
  fi

  if ! has_marker "$file"; then
    echo "No marker found in: $file" >&2
    return 0
  fi

  local ext="${file##*.}"
  local temp_file=""
  temp_file=$(mktemp)
  chmod 600 "$temp_file"

  case "$ext" in
    sh)
      # Keep shebang, remove marker lines
      if head -1 "$file" | grep -q "^#!"; then
        head -1 "$file" > "$temp_file"
        tail -n +2 "$file" | grep -v "^#.*$MARKER_PREFIX" | grep -v "^#.*$WARNING_LINE" >> "$temp_file"
      else
        grep -v "^#.*$MARKER_PREFIX" "$file" | grep -v "^#.*$WARNING_LINE" > "$temp_file"
      fi
      ;;
    md)
      grep -v "<!--.*$MARKER_PREFIX" "$file" > "$temp_file"
      ;;
    yaml|yml)
      grep -v "^#.*$MARKER_PREFIX" "$file" | grep -v "^#.*$WARNING_LINE" > "$temp_file"
      ;;
    json)
      if command -v jq &>/dev/null; then
        jq 'del(._loa_marker)' "$file" > "$temp_file"
      else
        cat "$file" > "$temp_file"
      fi
      ;;
    *)
      grep -v "$MARKER_PREFIX" "$file" | grep -v "$WARNING_LINE" > "$temp_file"
      ;;
  esac

  mv "$temp_file" "$file"
  echo "Removed marker from: $file"
}

# Update the hash in an existing marker to match current file content
# Usage: update_hash /path/to/file
# Returns: 0 on success, 1 on error
update_hash() {
  local file="${1:-}"

  if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
    echo "Error: File not found: $file" >&2
    return 1
  fi

  if ! has_marker "$file"; then
    echo "Error: No marker found in: $file" >&2
    return 1
  fi

  local ext="${file##*.}"
  local new_hash=""
  new_hash=$(compute_hash "$file")

  if [[ -z "$new_hash" ]]; then
    echo "Error: Could not compute hash for: $file" >&2
    return 1
  fi

  local temp_file=""
  temp_file=$(mktemp "${file}.update-hash-XXXXXX")
  chmod 600 "$temp_file"

  if [[ "$ext" == "json" ]]; then
    if command -v jq &>/dev/null; then
      jq --arg h "$new_hash" '._loa_marker.hash = $h' "$file" > "$temp_file"
    else
      echo "Error: jq required for JSON hash update" >&2
      rm -f "$temp_file"
      return 1
    fi
  else
    # Replace the hash value in the marker line
    sed "s/\(${MARKER_PREFIX}.*hash: \)[a-f0-9]*/\1${new_hash}/" "$file" > "$temp_file"
  fi

  mv "$temp_file" "$file"
  echo "Updated hash in: $file"
}

# =============================================================================
# CLI Interface
# =============================================================================

# Main CLI handler
main() {
  local cmd="${1:-help}"
  shift || true

  case "$cmd" in
    has-marker|has_marker)
      has_marker "$@" && echo "true" || echo "false"
      ;;
    has-pack-marker|has_pack_marker)
      has_pack_marker "$@" && echo "true" || echo "false"
      ;;
    get-version|get_marker_version)
      get_marker_version "$@"
      ;;
    compute-hash|compute_hash)
      compute_hash "$@"
      ;;
    verify-hash|verify_hash)
      verify_hash "$@"
      ;;
    add-marker|add_marker)
      add_marker "$@"
      ;;
    remove-marker|remove_marker)
      remove_marker "$@"
      ;;
    update-hash|update_hash)
      update_hash "$@"
      ;;
    batch-add)
      local version="${1:-1.15.0}"
      shift || true
      for file in "$@"; do
        add_marker "$file" "$version" || true
      done
      ;;
    batch-verify)
      local valid=0
      local invalid=0
      for file in "$@"; do
        local result=""
        result=$(verify_hash "$file")
        if [[ "$result" == "VALID" ]]; then
          ((valid++)) || true
        else
          ((invalid++)) || true
          echo "$result: $file"
        fi
      done
      echo "Valid: $valid, Invalid/Missing: $invalid"
      ;;
    help|--help|-h)
      cat <<EOF
Loa Marker Utilities

Usage: marker-utils.sh <command> [args]

Commands:
  has-marker <file>           Check if file has Loa marker
  has-pack-marker <file>      Check if file has pack marker
  get-version <file>          Get version from marker
  compute-hash <file>         Compute SHA-256 of content (excluding marker)
  verify-hash <file>          Verify file hash matches marker
  update-hash <file>          Recompute and update hash in existing marker
  add-marker <file> [version] Add marker to file
  remove-marker <file>        Remove marker from file
  batch-add <version> <files> Add markers to multiple files
  batch-verify <files>        Verify multiple files

Examples:
  marker-utils.sh has-marker .claude/scripts/update.sh
  marker-utils.sh verify-hash .claude/skills/loa-*/SKILL.md
  marker-utils.sh add-marker script.sh "1.15.0"
EOF
      ;;
    *)
      echo "Unknown command: $cmd" >&2
      echo "Run 'marker-utils.sh help' for usage" >&2
      return 1
      ;;
  esac
}

# Only run main if executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
