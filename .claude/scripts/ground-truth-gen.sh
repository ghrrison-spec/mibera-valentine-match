#!/usr/bin/env bash
# ground-truth-gen.sh - Grounded Truth mechanical operations
# Version: 1.0.0
#
# Handles checksums, token validation, and directory scaffolding for
# Grounded Truth output. Content generation is handled by the riding-codebase
# skill (Phase 11) — this script handles the mechanical parts only.
#
# Usage:
#   .claude/scripts/ground-truth-gen.sh \
#     --reality-dir grimoires/loa/reality/ \
#     --output-dir grimoires/loa/ground-truth/ \
#     --max-tokens-per-section 2000
#
# Exit Codes:
#   0 - Success
#   1 - Validation failure (token budget exceeded)
#   2 - Missing dependencies or invalid arguments

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/bootstrap.sh"

# =============================================================================
# Defaults
# =============================================================================

REALITY_DIR=""
OUTPUT_DIR=""
MAX_TOKENS_PER_SECTION=2000
INDEX_MAX_TOKENS=500
MODE="scaffold"  # scaffold | checksums | validate | all

# =============================================================================
# Usage
# =============================================================================

usage() {
  cat <<'USAGE'
Usage: ground-truth-gen.sh [OPTIONS]

Options:
  --reality-dir DIR          Source reality directory (required for checksums)
  --output-dir DIR           Output directory for GT files (required)
  --max-tokens-per-section N Maximum tokens per section file (default: 2000)
  --index-max-tokens N       Maximum tokens for index.md (default: 500)
  --mode MODE                Operation mode: scaffold|checksums|validate|all (default: scaffold)
  --help                     Show this help

Modes:
  scaffold   Create output directory structure with placeholder files
  checksums  Compute SHA-256 checksums for source files referenced in reality/
  validate   Validate token budgets for existing GT files
  all        Run scaffold + checksums + validate

Exit Codes:
  0  Success
  1  Validation failure (token budget exceeded)
  2  Missing dependencies or invalid arguments
USAGE
  exit "${1:-0}"
}

# =============================================================================
# Argument Parsing
# =============================================================================

while [[ $# -gt 0 ]]; do
  case "$1" in
    --reality-dir)
      REALITY_DIR="$2"
      shift 2
      ;;
    --output-dir)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    --max-tokens-per-section)
      MAX_TOKENS_PER_SECTION="$2"
      shift 2
      ;;
    --index-max-tokens)
      INDEX_MAX_TOKENS="$2"
      shift 2
      ;;
    --mode)
      MODE="$2"
      shift 2
      ;;
    --help)
      usage 0
      ;;
    *)
      echo "ERROR: Unknown argument: $1" >&2
      usage 2
      ;;
  esac
done

# =============================================================================
# Dependency Checks
# =============================================================================

check_dependencies() {
  local missing=0

  if ! command -v jq &>/dev/null; then
    echo "ERROR: jq is required but not installed" >&2
    missing=1
  fi

  if ! command -v sha256sum &>/dev/null && ! command -v shasum &>/dev/null; then
    echo "ERROR: sha256sum or shasum is required but not installed" >&2
    missing=1
  fi

  if [[ $missing -ne 0 ]]; then
    exit 2
  fi
}

# =============================================================================
# Helpers
# =============================================================================

# Cross-platform SHA-256
compute_sha256() {
  local file="$1"
  if command -v sha256sum &>/dev/null; then
    sha256sum "$file" | awk '{print $1}'
  elif command -v shasum &>/dev/null; then
    shasum -a 256 "$file" | awk '{print $1}'
  fi
}

# Estimate tokens from word count (1 token ≈ 0.75 words)
estimate_tokens() {
  local file="$1"
  local words
  words=$(wc -w < "$file" 2>/dev/null || echo 0)
  # 1 token ≈ 0.75 words, so tokens ≈ words / 0.75 = words * 4/3
  echo $(( (words * 4 + 2) / 3 ))
}

# =============================================================================
# Scaffold Mode
# =============================================================================

do_scaffold() {
  if [[ -z "$OUTPUT_DIR" ]]; then
    echo "ERROR: --output-dir is required for scaffold mode" >&2
    exit 2
  fi

  mkdir -p "$OUTPUT_DIR"

  local gt_files=("index.md" "api-surface.md" "architecture.md" "contracts.md" "behaviors.md")

  for file in "${gt_files[@]}"; do
    local filepath="$OUTPUT_DIR/$file"
    if [[ ! -f "$filepath" ]]; then
      # Create placeholder — content will be generated by the riding-codebase skill
      touch "$filepath"
      echo "Created: $filepath"
    else
      echo "Exists:  $filepath"
    fi
  done

  echo "Scaffold complete: $OUTPUT_DIR"
}

# =============================================================================
# Checksums Mode
# =============================================================================

do_checksums() {
  if [[ -z "$REALITY_DIR" ]]; then
    echo "ERROR: --reality-dir is required for checksums mode" >&2
    exit 2
  fi

  if [[ ! -d "$REALITY_DIR" ]]; then
    echo "ERROR: Reality directory does not exist: $REALITY_DIR" >&2
    exit 2
  fi

  if [[ -z "$OUTPUT_DIR" ]]; then
    echo "ERROR: --output-dir is required for checksums mode" >&2
    exit 2
  fi

  mkdir -p "$OUTPUT_DIR"

  local git_sha
  git_sha=$(git rev-parse HEAD 2>/dev/null || echo "unknown")

  local generated_at
  generated_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  # Collect source files referenced in reality/ extraction
  # Parse file references from reality files (patterns like `src/foo.ts:42`)
  local -a source_files=()
  local -A seen_files=()

  while IFS= read -r reality_file; do
    # Extract file:line references from markdown content
    while IFS= read -r ref; do
      # Strip line numbers and backticks
      local filepath
      filepath=$(echo "$ref" | sed 's/`//g' | sed 's/:[0-9]*[-–][0-9]*//' | sed 's/:[0-9]*//')

      # Only include files that actually exist in the project
      local full_path="$PROJECT_ROOT/$filepath"
      if [[ -f "$full_path" ]] && [[ -z "${seen_files[$filepath]:-}" ]]; then
        source_files+=("$filepath")
        seen_files[$filepath]=1
      fi
    done < <(grep -oE '`[a-zA-Z0-9_./-]+\.[a-zA-Z]+:[0-9]+' "$reality_file" 2>/dev/null | sed 's/`//' || true)
  done < <(find "$REALITY_DIR" -name "*.md" -type f 2>/dev/null)

  # Also include reality files themselves
  while IFS= read -r reality_file; do
    local rel_path
    rel_path=$(realpath --relative-to="$PROJECT_ROOT" "$reality_file" 2>/dev/null || echo "$reality_file")
    if [[ -z "${seen_files[$rel_path]:-}" ]]; then
      source_files+=("$rel_path")
      seen_files[$rel_path]=1
    fi
  done < <(find "$REALITY_DIR" -name "*.md" -type f 2>/dev/null)

  # Build checksums JSON
  local files_json="{"
  local first=true

  for filepath in "${source_files[@]}"; do
    local full_path="$PROJECT_ROOT/$filepath"
    if [[ -f "$full_path" ]]; then
      local hash
      hash=$(compute_sha256 "$full_path")
      if [[ "$first" == "true" ]]; then
        first=false
      else
        files_json+=","
      fi
      files_json+="$(printf '\n    "%s": "%s"' "$filepath" "$hash")"
    fi
  done

  files_json+=$'\n  }'

  # Write checksums.json
  local checksums_file="$OUTPUT_DIR/checksums.json"
  cat > "$checksums_file" <<EOF
{
  "generated_at": "$generated_at",
  "git_sha": "$git_sha",
  "algorithm": "sha256",
  "files": $files_json
}
EOF

  local file_count=${#source_files[@]}
  echo "Checksums generated: $checksums_file ($file_count files)"
}

# =============================================================================
# Validate Mode
# =============================================================================

do_validate() {
  if [[ -z "$OUTPUT_DIR" ]]; then
    echo "ERROR: --output-dir is required for validate mode" >&2
    exit 2
  fi

  if [[ ! -d "$OUTPUT_DIR" ]]; then
    echo "ERROR: Output directory does not exist: $OUTPUT_DIR" >&2
    exit 2
  fi

  local has_failures=0

  echo "Token Budget Validation"
  echo "======================"
  printf "%-25s %8s %8s %6s\n" "Section" "Words" "~Tokens" "Status"
  printf "%-25s %8s %8s %6s\n" "-------" "-----" "-------" "------"

  for file in "$OUTPUT_DIR"/*.md; do
    [[ -f "$file" ]] || continue

    local basename
    basename=$(basename "$file")
    local words
    words=$(wc -w < "$file" 2>/dev/null || echo 0)
    local tokens
    tokens=$(estimate_tokens "$file")

    local limit=$MAX_TOKENS_PER_SECTION
    if [[ "$basename" == "index.md" ]]; then
      limit=$INDEX_MAX_TOKENS
    fi

    local status="PASS"
    if [[ $tokens -gt $limit ]]; then
      status="WARN"
      has_failures=1
    fi

    printf "%-25s %8d %8d %6s\n" "$basename" "$words" "$tokens" "$status"
  done

  echo ""
  if [[ $has_failures -ne 0 ]]; then
    echo "WARNING: Some sections exceed token budget"
    exit 1
  else
    echo "All sections within token budget"
    exit 0
  fi
}

# =============================================================================
# Main
# =============================================================================

check_dependencies

case "$MODE" in
  scaffold)
    do_scaffold
    ;;
  checksums)
    do_checksums
    ;;
  validate)
    do_validate
    ;;
  all)
    do_scaffold
    do_checksums
    do_validate
    ;;
  *)
    echo "ERROR: Unknown mode: $MODE" >&2
    usage 2
    ;;
esac
