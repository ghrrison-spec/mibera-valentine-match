/**
 * Beads Abstract Interfaces
 *
 * Abstract interfaces for extensible beads_rust integration.
 * Implementors can create custom adapters for WAL, scheduling,
 * and state persistence.
 *
 * @module beads/interfaces
 * @version 1.0.0
 * @origin Extracted from loa-beauvoir production implementation
 */

// =============================================================================
// Bead Types (matching br CLI output)
// =============================================================================

/**
 * Represents a bead from beads_rust (br CLI output)
 *
 * @example
 * ```typescript
 * const bead: Bead = {
 *   id: "task-123",
 *   title: "Implement feature X",
 *   type: "task",
 *   status: "open",
 *   priority: 2,
 *   labels: ["sprint:1", "sprint:in_progress"],
 *   created_at: "2026-01-15T10:00:00Z",
 *   updated_at: "2026-01-15T12:30:00Z",
 * };
 * ```
 */
export interface Bead {
  /** Unique bead identifier */
  id: string;

  /** Bead title/summary */
  title: string;

  /** Bead type (task, bug, feature, epic, story, debt, spike) */
  type: string;

  /** Status: open or closed */
  status: "open" | "closed";

  /** Priority (0-10, lower is higher priority) */
  priority: number;

  /** Labels attached to this bead */
  labels: string[];

  /** Optional description/body */
  description?: string;

  /** ISO timestamp of creation */
  created_at: string;

  /** ISO timestamp of last update */
  updated_at: string;

  /** Parent bead ID if this is a child */
  parent_id?: string;

  /** Beads this one depends on */
  depends_on?: string[];

  /** Beads that depend on this one */
  blocked_by?: string[];
}

/**
 * Options for creating a new bead
 */
export interface BeadCreateOptions {
  /** Bead title/summary */
  title: string;

  /** Bead type */
  type: "task" | "bug" | "feature" | "epic" | "story" | "debt" | "spike";

  /** Priority (0-10) */
  priority?: number;

  /** Initial labels */
  labels?: string[];

  /** Optional description */
  description?: string;

  /** Parent bead ID */
  parent_id?: string;
}

/**
 * Options for querying beads
 */
export interface BeadQueryOptions {
  /** Filter by label */
  label?: string;

  /** Filter by type */
  type?: string;

  /** Filter by status */
  status?: "open" | "closed";

  /** Filter by parent ID */
  parent_id?: string;

  /** Limit number of results */
  limit?: number;
}

// =============================================================================
// WAL (Write-Ahead Log) Interface
// =============================================================================

/**
 * Entry in the write-ahead log
 *
 * @example
 * ```typescript
 * const entry: WALEntry = {
 *   id: "wal-001",
 *   timestamp: "2026-01-15T10:00:00Z",
 *   operation: "create",
 *   beadId: "task-123",
 *   payload: { title: "New task", type: "task" },
 *   status: "pending",
 * };
 * ```
 */
export interface WALEntry {
  /** Unique entry identifier */
  id: string;

  /** ISO timestamp when entry was created */
  timestamp: string;

  /** Operation type */
  operation: "create" | "update" | "close" | "reopen" | "label" | "comment" | "dep";

  /** Target bead ID (may be null for create operations) */
  beadId: string | null;

  /** Operation payload (operation-specific) */
  payload: Record<string, unknown>;

  /** Entry status */
  status: "pending" | "applied" | "failed" | "skipped";

  /** Error message if status is "failed" */
  error?: string;

  /** Number of retry attempts */
  retryCount?: number;
}

/**
 * Interface for Write-Ahead Log adapters
 *
 * WAL provides crash recovery by logging operations before execution.
 * On recovery, pending entries can be replayed.
 *
 * @example
 * ```typescript
 * class FileWALAdapter implements IWALAdapter {
 *   async append(entry: Omit<WALEntry, "id" | "timestamp">): Promise<string> {
 *     const id = generateId();
 *     const fullEntry = { ...entry, id, timestamp: new Date().toISOString() };
 *     await fs.appendFile(this.path, JSON.stringify(fullEntry) + "\n");
 *     return id;
 *   }
 *   // ... other methods
 * }
 * ```
 */
export interface IWALAdapter {
  /**
   * Append a new entry to the WAL
   *
   * @param entry - Entry without id/timestamp (generated by adapter)
   * @returns Promise resolving to the generated entry ID
   */
  append(entry: Omit<WALEntry, "id" | "timestamp">): Promise<string>;

  /**
   * Get all entries with pending status for replay
   *
   * @returns Promise resolving to array of pending entries
   */
  getPendingEntries(): Promise<WALEntry[]>;

  /**
   * Mark an entry as applied after successful execution
   *
   * @param entryId - ID of the entry to mark
   */
  markApplied(entryId: string): Promise<void>;

  /**
   * Mark an entry as failed with error message
   *
   * @param entryId - ID of the entry to mark
   * @param error - Error message
   */
  markFailed(entryId: string, error: string): Promise<void>;

  /**
   * Replay all pending entries
   *
   * @param executor - Function to execute each entry
   * @returns Promise resolving to number of entries replayed
   */
  replay(executor: (entry: WALEntry) => Promise<void>): Promise<number>;

  /**
   * Truncate WAL by removing applied entries older than timestamp
   *
   * @param olderThan - ISO timestamp cutoff
   */
  truncate(olderThan: string): Promise<void>;
}

// =============================================================================
// Scheduler Interface
// =============================================================================

/**
 * A scheduled task definition
 *
 * @example
 * ```typescript
 * const task: SchedulerTask = {
 *   id: "health-check",
 *   name: "Beads Health Check",
 *   intervalMs: 60000, // 1 minute
 *   handler: async () => { await checkHealth(); },
 *   enabled: true,
 * };
 * ```
 */
export interface SchedulerTask {
  /** Unique task identifier */
  id: string;

  /** Human-readable task name */
  name: string;

  /** Interval in milliseconds */
  intervalMs: number;

  /** Async handler function to execute */
  handler: () => Promise<void>;

  /** Whether task is currently enabled */
  enabled: boolean;

  /** Last execution timestamp */
  lastRun?: string;

  /** Last execution error (if any) */
  lastError?: string;

  /** Number of consecutive failures */
  failureCount?: number;

  /** Maximum consecutive failures before auto-disable */
  maxFailures?: number;
}

/**
 * Interface for task schedulers
 *
 * Schedulers manage periodic background tasks like health checks,
 * state synchronization, and WAL truncation.
 *
 * @example
 * ```typescript
 * class IntervalScheduler implements IScheduler {
 *   private intervals = new Map<string, NodeJS.Timeout>();
 *
 *   async register(task: SchedulerTask): Promise<void> {
 *     const id = setInterval(task.handler, task.intervalMs);
 *     this.intervals.set(task.id, id);
 *   }
 *   // ... other methods
 * }
 * ```
 */
export interface IScheduler {
  /**
   * Register a new scheduled task
   *
   * @param task - Task definition
   */
  register(task: SchedulerTask): Promise<void>;

  /**
   * Enable a task by ID
   *
   * @param taskId - ID of task to enable
   */
  enable(taskId: string): Promise<void>;

  /**
   * Disable a task by ID
   *
   * @param taskId - ID of task to disable
   */
  disable(taskId: string): Promise<void>;

  /**
   * Unregister (remove) a task
   *
   * @param taskId - ID of task to remove
   */
  unregister(taskId: string): Promise<void>;

  /**
   * Get status of all registered tasks
   *
   * @returns Array of task definitions with current status
   */
  getStatus(): Promise<SchedulerTask[]>;

  /**
   * Manually trigger a task execution
   *
   * @param taskId - ID of task to run
   */
  runNow(taskId: string): Promise<void>;

  /**
   * Shutdown scheduler and all tasks
   */
  shutdown(): Promise<void>;
}

// =============================================================================
// State Store Interface
// =============================================================================

/**
 * Generic interface for state persistence
 *
 * Provides typed get/set operations for persisting state.
 * Implementations can use files, databases, or other backends.
 *
 * @typeParam T - Type of state being stored
 *
 * @example
 * ```typescript
 * interface RunModeState {
 *   state: "READY" | "RUNNING" | "HALTED";
 *   currentSprint?: string;
 * }
 *
 * class JsonStateStore<T> implements IStateStore<T> {
 *   constructor(private path: string) {}
 *
 *   async get(): Promise<T | null> {
 *     try {
 *       return JSON.parse(await fs.readFile(this.path, "utf-8"));
 *     } catch { return null; }
 *   }
 *
 *   async set(state: T): Promise<void> {
 *     await fs.writeFile(this.path, JSON.stringify(state, null, 2));
 *   }
 * }
 *
 * const store = new JsonStateStore<RunModeState>(".run/state.json");
 * ```
 */
export interface IStateStore<T> {
  /**
   * Get current state
   *
   * @returns Promise resolving to state or null if not found
   */
  get(): Promise<T | null>;

  /**
   * Set/update state
   *
   * @param state - New state value
   */
  set(state: T): Promise<void>;

  /**
   * Clear state (delete)
   */
  clear(): Promise<void>;

  /**
   * Check if state exists
   *
   * @returns Promise resolving to boolean
   */
  exists(): Promise<boolean>;
}

// =============================================================================
// BR Command Executor Interface
// =============================================================================

/**
 * Result from executing a br command
 */
export interface BrCommandResult {
  /** Whether command succeeded (exit code 0) */
  success: boolean;

  /** stdout output */
  stdout: string;

  /** stderr output */
  stderr: string;

  /** Exit code */
  exitCode: number;
}

/**
 * Interface for executing br CLI commands
 *
 * Allows for mocking in tests and alternative implementations.
 *
 * @example
 * ```typescript
 * class RealBrExecutor implements IBrExecutor {
 *   async exec(args: string): Promise<BrCommandResult> {
 *     const { stdout, stderr } = await execAsync(`br ${args}`);
 *     return { success: true, stdout, stderr, exitCode: 0 };
 *   }
 * }
 *
 * class MockBrExecutor implements IBrExecutor {
 *   private responses = new Map<string, BrCommandResult>();
 *
 *   mockResponse(pattern: string, result: BrCommandResult) {
 *     this.responses.set(pattern, result);
 *   }
 *
 *   async exec(args: string): Promise<BrCommandResult> {
 *     for (const [pattern, result] of this.responses) {
 *       if (args.includes(pattern)) return result;
 *     }
 *     throw new Error(`No mock for: ${args}`);
 *   }
 * }
 * ```
 */
export interface IBrExecutor {
  /**
   * Execute a br command
   *
   * @param args - Command arguments (without "br" prefix)
   * @returns Promise resolving to command result
   */
  exec(args: string): Promise<BrCommandResult>;

  /**
   * Execute br command and parse JSON output
   *
   * @param args - Command arguments (should include --json flag)
   * @returns Promise resolving to parsed JSON
   */
  execJson<T = unknown>(args: string): Promise<T>;
}

// =============================================================================
// Run State Manager Interface
// =============================================================================

/**
 * Sprint execution state
 */
export interface SprintState {
  /** Bead ID of the sprint */
  id: string;

  /** Sprint number */
  sprintNumber: number;

  /** Current status */
  status: "pending" | "in_progress" | "completed" | "halted";

  /** Total tasks in sprint */
  tasksTotal: number;

  /** Completed task count */
  tasksCompleted: number;

  /** Currently executing task ID */
  currentTaskId?: string;
}

/**
 * Circuit breaker record
 */
export interface CircuitBreakerRecord {
  /** Bead ID of the circuit breaker */
  beadId: string;

  /** Sprint ID that triggered the breaker */
  sprintId: string;

  /** Reason for halt */
  reason: string;

  /** Number of same-issue occurrences */
  failureCount: number;

  /** When circuit breaker was created */
  createdAt: string;

  /** When circuit breaker was resolved (if resolved) */
  resolvedAt?: string;
}

/**
 * Result of migration from .run/ to beads
 */
export interface MigrationResult {
  /** Whether migration succeeded */
  success: boolean;

  /** Number of sprints migrated */
  migratedSprints: number;

  /** Number of tasks migrated */
  migratedTasks: number;

  /** Number of circuit breakers created */
  circuitBreakersCreated: number;

  /** Any warnings during migration */
  warnings: string[];
}

/**
 * Configuration for BeadsRunStateManager
 */
export interface BeadsRunStateConfig {
  /** Command to run br (default: "br") */
  brCommand?: string;

  /** Enable verbose logging */
  verbose?: boolean;

  /** Custom br executor (for testing) */
  executor?: IBrExecutor;
}

/**
 * Interface for run-mode state management
 *
 * Provides operations for managing run lifecycle, sprints,
 * and circuit breakers using beads as backing store.
 */
export interface IBeadsRunStateManager {
  /**
   * Get current run state
   *
   * @returns Promise resolving to run state
   */
  getRunState(): Promise<"READY" | "RUNNING" | "HALTED" | "COMPLETE">;

  /**
   * Get current sprint being executed
   *
   * @returns Promise resolving to sprint state or null
   */
  getCurrentSprint(): Promise<SprintState | null>;

  /**
   * Get all sprints in the run plan
   *
   * @returns Promise resolving to array of sprint states
   */
  getSprintPlan(): Promise<SprintState[]>;

  /**
   * Start a new run with given sprint IDs
   *
   * @param sprintIds - Array of sprint bead IDs
   * @returns Promise resolving to run bead ID
   */
  startRun(sprintIds: string[]): Promise<string>;

  /**
   * Start executing a specific sprint
   *
   * @param sprintId - Sprint bead ID
   */
  startSprint(sprintId: string): Promise<void>;

  /**
   * Mark sprint as complete
   *
   * @param sprintId - Sprint bead ID
   */
  completeSprint(sprintId: string): Promise<void>;

  /**
   * Halt run with reason
   *
   * @param reason - Halt reason
   * @returns Promise resolving to circuit breaker record
   */
  haltRun(reason: string): Promise<CircuitBreakerRecord>;

  /**
   * Resume run by resolving circuit breakers
   */
  resumeRun(): Promise<void>;

  /**
   * Migrate from .run/ directory state
   *
   * @param dotRunPath - Path to .run/ directory
   * @returns Promise resolving to migration result
   */
  migrateFromDotRun(dotRunPath: string): Promise<MigrationResult>;
}
